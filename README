Runtime Machine Configuration (RMC)
================================================================================

RMC project provides BSP and OEM a new way to deal with configuration at a board
or product level on multiple hardware targets at runtime. It answers two
questions in a centralized approach:

1) A unified way to identify a type of board in a software stack

Developers run RMC tool on a running board to obtain a fingerprint file from a
running board. The fingerprint file is the identity of board 'type' in software.

Fingerprint file so far is the only RMC-specific data exposed to outside. Any
software calling RMC to get board-specific data doesn't need to carry finger-
print. It is only used to map data and board type in a RMC database.

2) Access to data associated to a type of board based on its identity at runtime

With the same RMC tool, developers can generate a RMC record file which contains
a signature computed from board's fingerprint and all data specific to the type
of board (provided by developers).

The next step is to use RMC tool to generate a RMC database file with records
for different boards.

At runtime, clients (software to call RMC) query files for the type of the
running board with filenames. Once called, via RMC tool or APIs provided from
RMC libraris, RMC collects fingerprint of the running board, computes its
signature, seeks any possible records in RMC database file (provided by callers),
to match the board it runs on with signatures, and then return the file blob
to caller if there is a blob with same name specified by the caller.

RMC tool (CLI) lives in Linux user space. RMC libraries provides APIs in C, so
that any programs can link with RMC libraries and call these APIs to get data
specific to a type of board at runtime. RMC libraries can also be linked in EFI
context for bootloaders, as well as in Linux user space.

Further refactor work is planned to simplify the integration
between RMC and other software clients.

With RMC, developer of a client software can have a generic implementation of
logic and hardcoded configuration file names in source code. RMC magically
returns data for the type of running board at runtime.

To compile RMC, simply run "make" in top directory of rmc project.

To get usage of RMC tool, just compile the project and run "rmc" without any
arguments. Examples are also provided in usage message, in a rough order of
recommended workflow.

Refer to rmcl.h and rsmp.h for APIs. RMC tool itself uses these APIs, so it can
be a good example (rmc.c).

To integrate RMC into a build system (yocto, Android...):
On build host, compile RMC tool for host architecture and use it to generate RMC
database files with all fingerprints and board-specific data checked in source
tree. Build system is responsible to manage fingerprints and data. RMC database
files shall be available in live-boot or installer image.

For target, compile RMC tool and libraries again for target architecture. RMC
tool, an executable, can be deployed to target for clients like scripts. RMC
libraries are expected to be linked in programs.

Board is required to have UEFI and SMBIOS compliant firmware. The efi driver in
Linux kernel is also necessary.
